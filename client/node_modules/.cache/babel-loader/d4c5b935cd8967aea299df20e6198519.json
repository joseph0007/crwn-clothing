{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"C:\\\\React\\\\crwn-clothing\\\\src\\\\App.js\";\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport { createStructuredSelector } from \"reselect\";\nimport { withRouter } from \"react-router-dom\";\nimport \"./App.css\";\nimport { HomePage } from \"./pages/homepage/homepage.page.jsx\";\nimport Shop from \"./pages/shoppage/shoppage.page\";\nimport { Route, Switch, Redirect } from \"react-router-dom\";\nimport Header from \"./components/header/header.component\";\nimport SignInPage from \"./pages/signpage/signpage.component\";\nimport CheckOut from \"./pages/checkout/checkout.pages\";\nimport { auth, createUserDocDB } from \"./utils/firebase/firebase.utils\";\nimport { checkUserAuthStateStart } from \"./redux/users/users.actions\";\nimport { selectCurrentUser } from \"./redux/users/users.selectors\";\n/**\n * a common issue with client side rendering was the issue of routing as opposed to server side rendering where we render the\n * page on the server side and send the new html page to the client.\n * there was no way of routing and constructing url endpoints to hit different pages because we were not relying on server anymore\n * to render the html but instead the client!!\n * but this issue was solved with client side routing which useses something that was build into the browser to route!!\n */\n// const Hats = (props) => (\n//   <div>\n//     {console.log(props)}\n//     <h1>Hats</h1>\n//   </div>\n// );\n\n/**\n * Switch component just checks for the route inside of it and renders the first component that matches the url endpoint and ignores the\n * rest of the route and thus solving the issue of multiple components getting rendered due to all the route getting hit!!\n *\n */\n\nclass App extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.unsubscribeFromAuth = null;\n  }\n\n  componentDidMount() {\n    const {\n      checkUserAuthState\n    } = this.props;\n    checkUserAuthState();\n  }\n\n  componentWillUnmount() {\n    this.unsubscribeFromAuth();\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"App\",\n      children: [/*#__PURE__*/_jsxDEV(Header, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 68,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(Switch, {\n        children: [/*#__PURE__*/_jsxDEV(Route, {\n          exact: true,\n          path: \"/\",\n          component: HomePage\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 70,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(Route, {\n          path: \"/shop\",\n          component: Shop\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 71,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(Route, {\n          exact: true,\n          path: \"/checkout\",\n          component: CheckOut\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 72,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(Route, {\n          exact: true,\n          path: \"/signin\",\n          render: () => this.props.currentUser ? /*#__PURE__*/_jsxDEV(Redirect, {\n            to: \"/\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 78,\n            columnNumber: 17\n          }, this) : /*#__PURE__*/_jsxDEV(SignInPage, {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 80,\n            columnNumber: 17\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 73,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 69,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 64,\n      columnNumber: 7\n    }, this);\n  }\n\n} // subscriber function: constantly listens for any change!!(like an event Listener)\n\n\nconst mapStateToProps = createStructuredSelector({\n  currentUser: selectCurrentUser\n}); // ownProps is the props that are passed to the element when it is called somewhere!!\n// react-redux re-renders the component when the new props are passed and the ownProps is passed as second argument to\n// mapDispatchToProps function!! but it will not re-render even if props change when ownProps is not passed!\n\nconst mapDispatchToProps = dispatch => ({\n  checkUserAuthState: () => dispatch(checkUserAuthStateStart())\n});\n\nexport default withRouter(connect(mapStateToProps, mapDispatchToProps)(App));","map":{"version":3,"sources":["C:/React/crwn-clothing/src/App.js"],"names":["React","connect","createStructuredSelector","withRouter","HomePage","Shop","Route","Switch","Redirect","Header","SignInPage","CheckOut","auth","createUserDocDB","checkUserAuthStateStart","selectCurrentUser","App","Component","unsubscribeFromAuth","componentDidMount","checkUserAuthState","props","componentWillUnmount","render","currentUser","mapStateToProps","mapDispatchToProps","dispatch"],"mappings":";;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,OAAT,QAAwB,aAAxB;AACA,SAASC,wBAAT,QAAyC,UAAzC;AACA,SAASC,UAAT,QAA2B,kBAA3B;AAEA,OAAO,WAAP;AACA,SAASC,QAAT,QAAyB,oCAAzB;AACA,OAAOC,IAAP,MAAiB,gCAAjB;AACA,SAASC,KAAT,EAAgBC,MAAhB,EAAwBC,QAAxB,QAAwC,kBAAxC;AACA,OAAOC,MAAP,MAAmB,sCAAnB;AACA,OAAOC,UAAP,MAAuB,qCAAvB;AACA,OAAOC,QAAP,MAAqB,iCAArB;AACA,SAASC,IAAT,EAAeC,eAAf,QAAsC,iCAAtC;AACA,SAASC,uBAAT,QAAwC,6BAAxC;AACA,SAASC,iBAAT,QAAkC,+BAAlC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,GAAN,SAAkBhB,KAAK,CAACiB,SAAxB,CAAkC;AAAA;AAAA;AAAA,SAYhCC,mBAZgC,GAYV,IAZU;AAAA;;AAchCC,EAAAA,iBAAiB,GAAG;AAClB,UAAM;AAAEC,MAAAA;AAAF,QAAyB,KAAKC,KAApC;AAEAD,IAAAA,kBAAkB;AACnB;;AAEDE,EAAAA,oBAAoB,GAAG;AACrB,SAAKJ,mBAAL;AACD;;AAEDK,EAAAA,MAAM,GAAG;AACP,wBACE;AAAK,MAAA,SAAS,EAAC,KAAf;AAAA,8BAIE,QAAC,MAAD;AAAA;AAAA;AAAA;AAAA,cAJF,eAKE,QAAC,MAAD;AAAA,gCACE,QAAC,KAAD;AAAO,UAAA,KAAK,MAAZ;AAAa,UAAA,IAAI,EAAC,GAAlB;AAAsB,UAAA,SAAS,EAAEnB;AAAjC;AAAA;AAAA;AAAA;AAAA,gBADF,eAEE,QAAC,KAAD;AAAO,UAAA,IAAI,EAAC,OAAZ;AAAoB,UAAA,SAAS,EAAEC;AAA/B;AAAA;AAAA;AAAA;AAAA,gBAFF,eAGE,QAAC,KAAD;AAAO,UAAA,KAAK,MAAZ;AAAa,UAAA,IAAI,EAAC,WAAlB;AAA8B,UAAA,SAAS,EAAEM;AAAzC;AAAA;AAAA;AAAA;AAAA,gBAHF,eAIE,QAAC,KAAD;AACE,UAAA,KAAK,MADP;AAEE,UAAA,IAAI,EAAC,SAFP;AAGE,UAAA,MAAM,EAAE,MACN,KAAKU,KAAL,CAAWG,WAAX,gBACE,QAAC,QAAD;AAAU,YAAA,EAAE,EAAC;AAAb;AAAA;AAAA;AAAA;AAAA,kBADF,gBAGE,QAAC,UAAD;AAAA;AAAA;AAAA;AAAA;AAPN;AAAA;AAAA;AAAA;AAAA,gBAJF;AAAA;AAAA;AAAA;AAAA;AAAA,cALF;AAAA;AAAA;AAAA;AAAA;AAAA,YADF;AAwBD;;AAjD+B,C,CAoDlC;;;AACA,MAAMC,eAAe,GAAGvB,wBAAwB,CAAC;AAC/CsB,EAAAA,WAAW,EAAET;AADkC,CAAD,CAAhD,C,CAIA;AACA;AACA;;AACA,MAAMW,kBAAkB,GAAIC,QAAD,KAAe;AACxCP,EAAAA,kBAAkB,EAAE,MAAMO,QAAQ,CAACb,uBAAuB,EAAxB;AADM,CAAf,CAA3B;;AAIA,eAAeX,UAAU,CAACF,OAAO,CAACwB,eAAD,EAAkBC,kBAAlB,CAAP,CAA6CV,GAA7C,CAAD,CAAzB","sourcesContent":["import React from \"react\";\nimport { connect } from \"react-redux\";\nimport { createStructuredSelector } from \"reselect\";\nimport { withRouter } from \"react-router-dom\";\n\nimport \"./App.css\";\nimport { HomePage } from \"./pages/homepage/homepage.page.jsx\";\nimport Shop from \"./pages/shoppage/shoppage.page\";\nimport { Route, Switch, Redirect } from \"react-router-dom\";\nimport Header from \"./components/header/header.component\";\nimport SignInPage from \"./pages/signpage/signpage.component\";\nimport CheckOut from \"./pages/checkout/checkout.pages\";\nimport { auth, createUserDocDB } from \"./utils/firebase/firebase.utils\";\nimport { checkUserAuthStateStart } from \"./redux/users/users.actions\";\nimport { selectCurrentUser } from \"./redux/users/users.selectors\";\n\n/**\n * a common issue with client side rendering was the issue of routing as opposed to server side rendering where we render the\n * page on the server side and send the new html page to the client.\n * there was no way of routing and constructing url endpoints to hit different pages because we were not relying on server anymore\n * to render the html but instead the client!!\n * but this issue was solved with client side routing which useses something that was build into the browser to route!!\n */\n\n// const Hats = (props) => (\n//   <div>\n//     {console.log(props)}\n//     <h1>Hats</h1>\n//   </div>\n// );\n\n/**\n * Switch component just checks for the route inside of it and renders the first component that matches the url endpoint and ignores the\n * rest of the route and thus solving the issue of multiple components getting rendered due to all the route getting hit!!\n *\n */\n\nclass App extends React.Component {\n  // constructor() {\n  //   super();\n\n  //   this.state = {\n  //     currentUser: null,\n  //     // is used to get access to the actualDOM element (ref.current)\n  //     // ref={this.state.ref} should be passed into the element that you want the reference of !!\n  //     ref: React.createRef(),\n  //   };\n  // }\n\n  unsubscribeFromAuth = null;\n\n  componentDidMount() {\n    const { checkUserAuthState } = this.props;\n\n    checkUserAuthState();\n  }\n\n  componentWillUnmount() {\n    this.unsubscribeFromAuth();\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        {/* {console.log(this.state.ref)} */}\n        {/* {console.log(this.props)} */}\n        {/* <Header currentUser={this.state.currentUser} /> */}\n        <Header />\n        <Switch>\n          <Route exact path=\"/\" component={HomePage} />\n          <Route path=\"/shop\" component={Shop} />\n          <Route exact path=\"/checkout\" component={CheckOut} />\n          <Route\n            exact\n            path=\"/signin\"\n            render={() =>\n              this.props.currentUser ? (\n                <Redirect to=\"/\"></Redirect>\n              ) : (\n                <SignInPage />\n              )\n            }\n          />\n        </Switch>\n      </div>\n    );\n  }\n}\n\n// subscriber function: constantly listens for any change!!(like an event Listener)\nconst mapStateToProps = createStructuredSelector({\n  currentUser: selectCurrentUser,\n});\n\n// ownProps is the props that are passed to the element when it is called somewhere!!\n// react-redux re-renders the component when the new props are passed and the ownProps is passed as second argument to\n// mapDispatchToProps function!! but it will not re-render even if props change when ownProps is not passed!\nconst mapDispatchToProps = (dispatch) => ({\n  checkUserAuthState: () => dispatch(checkUserAuthStateStart()),\n});\n\nexport default withRouter(connect(mapStateToProps, mapDispatchToProps)(App));\n"]},"metadata":{},"sourceType":"module"}